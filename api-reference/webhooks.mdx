---
title: 'Webhooks'
description: 'Receive real-time notifications for message signatures and authorization events'
---

## Overview

Webhooks allow your application to receive real-time notifications for specific UIP events. UIP sends POST requests to your configured webhook URL with cryptographically signed payloads.

<Note>
**Webhooks are only used for:**
- **Message API** -- when a user signs or declines a signature-required message
- **Authorize API** -- when a business owner approves delegation (`authorize.completed`)
- **Delegation revocation** -- when a business revokes platform access (`delegation.revoked`)
- **Webhook testing** -- when you call the test endpoint

**Identify and Sign APIs do NOT use webhooks.** Use polling with `GET /v1/identify/:id` or `GET /v1/sign/:id` instead.
</Note>

## Setting Up Webhooks

### 1. Configure Webhook URL

1. Log into the [Business Dashboard](https://uip.digital)
2. Navigate to **Settings** > **Webhooks**
3. Enter your webhook endpoint URL (must use HTTPS in production)
4. Save your configuration

<Warning>
**HTTPS Required:** Production webhook URLs must use HTTPS. HTTP URLs are not allowed for security reasons.
</Warning>

### 2. Retrieve Webhook Secret

Your webhook secret is used to verify that requests are actually from UIP and haven't been tampered with.

1. In the Business Dashboard, go to **Settings** > **Webhooks**
2. Copy your **Webhook Secret** (shown after saving your webhook URL)
3. Store this secret securely in your application's environment variables

<Warning>
**Keep Secret Secure:** Never commit your webhook secret to version control or expose it in client-side code. Treat it like a password.
</Warning>

## Verifying Webhook Signatures

Every webhook request includes an `X-UIP-Signature` header containing an HMAC SHA-256 signature. You **must** verify this signature to ensure requests are from UIP.

### Signature Verification Algorithm

1. Get the `X-UIP-Signature` header from the request
2. Calculate HMAC SHA-256 hash of the raw request body using your webhook secret
3. Compare the calculated signature with the header value
4. Reject the request if signatures don't match

### Implementation Examples

<CodeGroup>

```javascript Node.js
const crypto = require('crypto');

app.post('/webhook', (req, res) => {
  const signature = req.headers['x-uip-signature'];
  const webhookSecret = process.env.UIP_WEBHOOK_SECRET;

  // Calculate expected signature
  const hmac = crypto.createHmac('sha256', webhookSecret);
  hmac.update(JSON.stringify(req.body));
  const expectedSignature = hmac.digest('hex');

  // Verify signature
  if (signature !== expectedSignature) {
    return res.status(401).send('Invalid signature');
  }

  // Handle webhook event
  const { event, data } = req.body;

  res.status(200).send('OK');
});
```

```python Python
import hmac
import hashlib
from flask import Flask, request

app = Flask(__name__)

@app.route('/webhook', methods=['POST'])
def webhook():
    signature = request.headers.get('X-UIP-Signature')
    webhook_secret = os.environ.get('UIP_WEBHOOK_SECRET')

    # Calculate expected signature
    body_bytes = request.get_data()
    expected_signature = hmac.new(
        webhook_secret.encode('utf-8'),
        body_bytes,
        hashlib.sha256
    ).hexdigest()

    # Verify signature
    if signature != expected_signature:
        return 'Invalid signature', 401

    # Handle webhook event
    data = request.get_json()
    event = data.get('event')

    return 'OK', 200
```

```go Go
package main

import (
    "crypto/hmac"
    "crypto/sha256"
    "encoding/hex"
    "encoding/json"
    "io/ioutil"
    "net/http"
    "os"
)

func webhookHandler(w http.ResponseWriter, r *http.Request) {
    signature := r.Header.Get("X-UIP-Signature")
    webhookSecret := os.Getenv("UIP_WEBHOOK_SECRET")

    // Read body
    body, err := ioutil.ReadAll(r.Body)
    if err != nil {
        http.Error(w, "Failed to read body", http.StatusBadRequest)
        return
    }

    // Calculate expected signature
    h := hmac.New(sha256.New, []byte(webhookSecret))
    h.Write(body)
    expectedSignature := hex.EncodeToString(h.Sum(nil))

    // Verify signature
    if signature != expectedSignature {
        http.Error(w, "Invalid signature", http.StatusUnauthorized)
        return
    }

    // Handle webhook event
    var payload map[string]interface{}
    json.Unmarshal(body, &payload)

    w.WriteHeader(http.StatusOK)
}
```

</CodeGroup>

## Webhook Events

### Event: `message`

Sent when a user signs or declines a signature-required message via the [Message API](/api-reference/endpoint/message).

```json
{
  "event": "message",
  "data": {
    "signing_uip_id": "user_abc123def456",
    "message_id": "msg_xyz789abc123",
    "audit_id": "audit_9z8y7x6w5v4u"
  }
}
```

**Fields:**
- `signing_uip_id` - UIP ID of the user who signed or declined
- `message_id` - Message ID from your original request
- `audit_id` - Permanent audit trail reference (save for compliance)

<Info>
**Determining Action:** The webhook structure is identical for both signed and declined messages. Query the [Audit API](/api-reference/endpoint/audit) using the `audit_id` to determine if the user signed or declined.
</Info>

### Event: `authorize.completed`

Sent when a business owner approves a platform delegation request via the [Authorize API](/api-reference/endpoint/authorize).

```json
{
  "event": "authorize.completed",
  "session_id": "sess_auth_1a2b3c4d",
  "timestamp": "2025-01-11T12:31:00Z",
  "data": {
    "access_token": "uip_at_abc123xyz789..."
  }
}
```

### Event: `delegation.revoked`

Sent when a business revokes a platform's delegation access.

```json
{
  "event": "delegation.revoked",
  "timestamp": "2025-01-11T12:31:00Z",
  "data": {
    "business_uip_id": "business_abc123"
  }
}
```

### Event: `test`

Sent when you test your webhook configuration via the [Test Webhook endpoint](/api-reference/endpoint/webhook-test).

```json
{
  "event": "test",
  "timestamp": "2025-01-11T12:30:00Z",
  "test": true
}
```

**Purpose:** Verify your webhook endpoint is reachable and correctly validates signatures.

## When Webhooks Are Sent

<AccordionGroup>
  <Accordion title="Message API" icon="envelope">
    **Webhook sent when:** User signs or declines a signature-required message (`signature_required: true`)

    **No webhook sent when:**
    - Message does not require signature (`signature_required: false`)
    - User doesn't respond and message expires
    - Message is invalidated before user responds
  </Accordion>

  <Accordion title="Authorize API" icon="users-gear">
    **Webhook sent when:** Business owner approves a delegation request

    **No webhook sent when:** Authorization session expires without approval
  </Accordion>

  <Accordion title="Delegation Revocation" icon="ban">
    **Webhook sent when:** A business revokes your platform's delegation access
  </Accordion>

  <Accordion title="Test Webhook" icon="flask">
    **Webhook sent when:** You call the [Test Webhook endpoint](/api-reference/endpoint/webhook-test)

    **Purpose:** Verify your webhook configuration before production use
  </Accordion>
</AccordionGroup>

## Best Practices

<CardGroup cols={2}>
  <Card title="Always Verify Signatures" icon="shield-check">
    Validate the X-UIP-Signature header on every request to prevent spoofing and tampering
  </Card>

  <Card title="Return 200 Quickly" icon="bolt">
    Process webhooks asynchronously and return 200 immediately to avoid timeouts
  </Card>

  <Card title="Store Audit IDs" icon="database">
    Save audit_id from every webhook for permanent proof, compliance, and legal verification
  </Card>

  <Card title="Handle Idempotency" icon="rotate">
    UIP may send the same webhook multiple times. Use audit_id or message_id to detect duplicates
  </Card>

  <Card title="Use HTTPS" icon="lock">
    Production webhook URLs must use HTTPS. HTTP is not allowed for security reasons.
  </Card>

  <Card title="Test Before Production" icon="flask">
    Use the Test Webhook endpoint during development to verify your setup works correctly
  </Card>
</CardGroup>

## Error Handling

If your webhook endpoint returns an error (non-200 status code) or times out, UIP will retry the webhook with exponential backoff.

**Retry Schedule:**
UIP retries webhook delivery once after a short delay. If both attempts fail, the webhook is marked as failed.

- Attempt 1: Immediate
- Attempt 2: After a short delay

<Warning>
**Handle Retries:** Design your webhook handler to be idempotent. Use `audit_id` or `message_id` to detect duplicate webhook deliveries.
</Warning>

## Webhook Handler Template

```javascript
const express = require('express');
const crypto = require('crypto');

const app = express();
app.use(express.json());

app.post('/webhook', async (req, res) => {
  // 1. Verify signature
  const signature = req.headers['x-uip-signature'];
  const webhookSecret = process.env.UIP_WEBHOOK_SECRET;

  const hmac = crypto.createHmac('sha256', webhookSecret);
  hmac.update(JSON.stringify(req.body));
  const expectedSignature = hmac.digest('hex');

  if (signature !== expectedSignature) {
    return res.status(401).send('Invalid signature');
  }

  // 2. Return 200 immediately
  res.status(200).send('OK');

  // 3. Process webhook asynchronously
  const { event, data } = req.body;

  try {
    switch (event) {
      case 'message':
        await handleMessage(data);
        break;
      case 'authorize.completed':
        await handleAuthorizeCompleted(data);
        break;
      case 'delegation.revoked':
        await handleDelegationRevoked(data);
        break;
      case 'test':
        console.log('Test webhook received');
        break;
      default:
        console.warn(`Unknown event type: ${event}`);
    }
  } catch (error) {
    console.error('Webhook processing error:', error);
  }
});

async function handleMessage(data) {
  const { signing_uip_id, message_id, audit_id } = data;

  // Check for duplicate
  const existing = await db.messageSignatures.findOne({ audit_id });
  if (existing) {
    console.log('Duplicate webhook, skipping');
    return;
  }

  // Query audit API to check if signed or declined
  const auditResponse = await fetch(
    `https://api.uip.digital/v1/audit/${audit_id}`,
    {
      headers: { 'Authorization': `Bearer ${process.env.UIP_API_KEY}` }
    }
  );

  const { audit } = await auditResponse.json();
  const wasSigned = audit.signed_accepted;

  // Save to database
  await db.messageSignatures.create({
    signing_uip_id,
    message_id,
    audit_id,
    was_signed: wasSigned,
    received_at: new Date()
  });

  // Handle based on outcome
  if (wasSigned) {
    await handleMessageSigned(message_id);
  } else {
    await handleMessageDeclined(message_id);
  }
}

async function handleAuthorizeCompleted(data) {
  const { access_token } = data;
  // Store delegation token securely
  await db.delegations.create({
    access_token,
    received_at: new Date()
  });
}

async function handleDelegationRevoked(data) {
  const { business_uip_id } = data;
  // Remove stored delegation token
  await db.delegations.delete({ business_uip_id });
}

app.listen(3000, () => {
  console.log('Webhook server listening on port 3000');
});
```

## Troubleshooting

<AccordionGroup>
  <Accordion title="Webhook unreachable error" icon="globe">
    **Problem:** API requests fail with `request/webhook-unreachable` error

    **Causes:**
    - Webhook URL is not publicly accessible
    - Firewall blocking UIP servers
    - Webhook handler not returning 200 status code
    - HTTPS certificate issues

    **Solutions:**
    - Verify webhook URL is publicly accessible
    - Check firewall rules allow incoming requests
    - Ensure webhook returns 200 status for all events
    - Use valid HTTPS certificate
  </Accordion>

  <Accordion title="Invalid signature" icon="key">
    **Problem:** Webhook receives requests but signature validation fails

    **Causes:**
    - Using wrong webhook secret
    - Calculating signature on modified body
    - Character encoding issues

    **Solutions:**
    - Get webhook secret from Business Dashboard settings
    - Calculate signature on raw request body (before parsing)
    - Use UTF-8 encoding for all strings
  </Accordion>

  <Accordion title="Webhook not configured" icon="link-slash">
    **Problem:** API requests fail with `request/webhook-missing` error

    **Causes:**
    - No webhook URL configured in Business Dashboard
    - Webhook URL field is empty

    **Solutions:**
    - Log into Business Dashboard
    - Navigate to Settings > Webhooks
    - Add your webhook endpoint URL
  </Accordion>

  <Accordion title="Duplicate webhooks" icon="clone">
    **Problem:** Receiving the same webhook multiple times

    **Causes:**
    - UIP retries webhooks if your server returns errors or times out
    - Network issues causing automatic retries

    **Solutions:**
    - Use `audit_id` or `message_id` to detect duplicates
    - Make webhook handler idempotent (safe to process multiple times)
    - Store processed webhook IDs in database to skip duplicates
  </Accordion>
</AccordionGroup>

## Related Resources

<CardGroup cols={2}>
  <Card title="Test Webhook" icon="flask" href="/api-reference/endpoint/webhook-test">
    Test your webhook configuration
  </Card>

  <Card title="Message API" icon="envelope" href="/api-reference/endpoint/message">
    Messages with webhook signature events
  </Card>

  <Card title="Authorize API" icon="users-gear" href="/api-reference/endpoint/authorize">
    Authorization with webhook completion events
  </Card>

  <Card title="Audit API" icon="list-check" href="/api-reference/endpoint/audit">
    Query audit records from webhooks
  </Card>

  <Card title="Error Handling" icon="triangle-exclamation" href="/core-concepts/error-handling">
    Handle API and webhook errors
  </Card>

  <Card title="Platform Delegation" icon="users-gear" href="/core-concepts/platform-delegation">
    Build platforms for multiple businesses
  </Card>
</CardGroup>
